#!/usr/bin/env python
# coding: utf-8
"""NatNet client ROS node.

Note that this node does not convert Motive's poses from y-up to z-up. You can do so with:
    rosrun tf static_transform_publisher 0 0 0 0 0 1.57079632679 mocap mocap_motive 100
Or just set Motive to z-up.
"""

from __future__ import print_function

import os.path

import rospy
import rospkg
from geometry_msgs.msg import Point, PointStamped, PoseStamped, Quaternion, TransformStamped, Vector3
from std_msgs.msg import ColorRGBA, Header
import tf
from visualization_msgs.msg import Marker

import natnet


class NatnetClientNode(object):

    def __init__(self):
        self.rigid_body_pubs = {}  # type: dict[int, rospy.Publisher]
        self.marker_pubs = {}  # type: dict[int, rospy.Publisher]
        self.marker_vis_pub = rospy.Publisher('~markers/vis', Marker, queue_size=10)
        self.tf_broadcaster = tf.TransformBroadcaster()
        self.client = None  # type: natnet.comms.Client
        self.mocap_frame = rospy.get_param('~mocap_frame', 'mocap')
        self.tf_remap = rospy.get_param('~tf_remap', {})  # type: dict

    def _publish_rigid_body_poses(self, header, rigid_bodies):
        """Publish ~rigid_bodies/i/pose topics."""
        for b in rigid_bodies:
            if not b.id_ in self.rigid_body_pubs:
                pub = rospy.Publisher('~rigid_bodies/{}/pose'.format(b.id_), PoseStamped, queue_size=10)
                self.rigid_body_pubs[b.id_] = pub
            message = PoseStamped()
            message.header = header
            message.pose.position = Point(*b.position)
            message.pose.orientation = Quaternion(*b.orientation)
            self.rigid_body_pubs[b.id_].publish(message)

    def _publish_rigid_body_tfs(self, header, rigid_bodies):
        """Publish mocap->bodyi transform for each rigid body."""
        for b in rigid_bodies:
            message = TransformStamped()
            message.header = header
            child_frame = self.tf_remap.get(str(b.id_), 'body{}'.format(b.id_))
            message.child_frame_id = child_frame
            message.transform.translation = Vector3(*b.position)
            message.transform.rotation = Quaternion(*b.orientation)
            self.tf_broadcaster.sendTransformMessage(message)

    def _publish_marker_vis(self, header, markers):
        """Publish ~markers/vis topic."""
        message = Marker()
        message.header = header
        message.ns = 'natnet_ros'
        message.id = 0
        message.type = Marker.SPHERE_LIST
        positions = [Point(*m.position) for m in markers]
        message.points = positions
        sizes = [m.size for m in markers]
        mean_size = sum(sizes) / len(sizes)
        message.scale = Vector3(mean_size, mean_size, mean_size)
        message.color = ColorRGBA(1, 1, 1, 1)
        self.marker_vis_pub.publish(message)

    def _publish_marker_points(self, header, markers):
        """Publish a PointStamped topic for each marker.

        For markers which are part of a rigid body, publish ~rigid_bodies/j/markeri topic.  Otherwise, publish
        ~markers/i topic.
        """
        for m in markers:
            try:
                pub = self.marker_pubs[(m.model_id, m.marker_id)]
            except KeyError:
                if m.model_id == 0:
                    topic = '~markers/{}'.format(m.marker_id)
                else:
                    topic = '~rigid_bodies/{}/marker{}'.format(m.model_id, m.marker_id)
                pub = rospy.Publisher(topic, PointStamped, queue_size=10)
                self.marker_pubs[(m.model_id, m.marker_id)] = pub
            message = PointStamped()
            message.header = header
            message.point = Point(*m.position)
            pub.publish(message)

    def mocap_frame_callback(self, rigid_bodies, markers, timing):
        """Handle a frame of mocap data."""
        print()
        print('{:.1f}s: Received mocap frame'.format(timing.timestamp))

        header = Header()
        header.frame_id = self.mocap_frame
        header.stamp = rospy.Time(timing.timestamp)

        if rigid_bodies:
            self._publish_rigid_body_poses(header, rigid_bodies)
            self._publish_rigid_body_tfs(header, rigid_bodies)
        if markers:
            self._publish_marker_points(header, markers)
            self._publish_marker_vis(header, markers)

    def run(self):
        if rospy.get_param('~fake', False):
            rospack = rospkg.RosPack()
            path = rospack.get_path('python_natnet')
            frame_filename = os.path.join(path, 'data', 'mocapframe_packet_v3.bin')
            info_filename = os.path.join(path, 'data', 'serverinfo_packet_v3.bin')
            client = natnet.fakes.FakeClient.fake_connect(frame_filename, info_filename)
        else:
            server = rospy.get_param('~server')
            client = natnet.Client.connect(server)
        client.set_callback(self.mocap_frame_callback)
        client.spin()


if __name__ == '__main__':
    rospy.init_node('mocap', disable_signals=True)
    try:
        node = NatnetClientNode()
        node.run()
    finally:
        # TODO: Handle ROS shutdown properly
        rospy.signal_shutdown(reason='Finished')
